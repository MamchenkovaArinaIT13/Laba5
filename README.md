 ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ №5 ПО JAVA
 Вариант 8

 ОБЩЕЕ ОПИСАНИЕ РАБОТЫ
Лабораторная работа №5 посвящена изучению шаблонов ООП, коллекций и Stream API в Java. Реализованы различные паттерны проектирования, работа с коллекциями, файловый ввод-вывод и функциональное программирование с использованием стримов. Все задачи реализованы в едином проекте с дружественным консольным интерфейсом, поддерживающим как ручной, так и автоматический ввод данных.

---

 ЗАДАНИЕ 1. ШАБЛОНЫ - ДРОБИ С КЭШИРОВАНИЕМ

 ОПИСАНИЕ КЛАССА Fraction
Реализация дроби с кэшированием вещественного значения и обработкой отрицательных чисел.

ПОЛЯ КЛАССА:
- private int numerator - числитель дроби
- private int denominator - знаменатель дроби
- private Float cachedFloatValue - кэшированное вещественное значение

ИНТЕРФЕЙС FractionInterface:
- float getFloat() - получение вещественного значения
- void setNumerator(int numerator) - установка числителя
- void setDenominator(int denominator) - установка знаменателя

КОНСТРУКТОРЫ:
- Fraction() - создает дробь 0/0
- Fraction(int numerator, int denominator) - создает дробь с валидацией

МЕТОДЫ ЛОГИКИ:
- Автоматическая нормализация знака при отрицательном знаменателе
- Ленивая инициализация вещественного значения
- Сброс кэша при изменении числителя или знаменателя
- Переопределение equals() и hashCode() для сравнения дробей

ИСКЛЮЧЕНИЯ:
- IllegalArgumentException при попытке установить знаменатель = 0

ТЕСТИРОВАНИЕ:
java
Fraction frac1 = new Fraction(1, 2);
Fraction frac2 = new Fraction(-2, 3);
System.out.println(frac1.getFloat()); // 0.5 (вычисление)
System.out.println(frac1.getFloat()); // 0.5 (из кэша)


---

 ЗАДАНИЕ 2. СТРУКТУРНЫЕ ШАБЛОНЫ - КОЛИЧЕСТВО МЯУКАНИЙ

 СУЩНОСТЬ КОТ
КЛАСС Cat:
- Реализует интерфейс Meowable
- Имеет имя (строка)
- Конструктор с именем
- toString() в формате "кот: Имя"
- meow() выводит "Имя: мяу!"

ИНТЕРФЕЙС Meowable:
- void meow() - метод мяуканья

КЛАСС Funs:
- meowsCare(Meowable meowable) - вызывает мяуканье 5 раз

СЧЕТЧИК МЯУКАНИЙ:
- Реализация через делегирование или прокси
- Подсчет количества вызовов метода meow()

ТЕСТИРОВАНИЕ:
java
Cat cat = new Cat("Мурзик");
MeowCounter counter = new MeowCounter(cat);
Funs.meowsCare(counter);
System.out.println("кот мяукал " + counter.getMeowCount() + " раз");
// Вывод: кот мяукал 5 раз


---

 ЗАДАНИЕ 3. СПИСОК - ПЕРЕСЕЧЕНИЕ ДВУХ СПИСКОВ

 КЛАСС ListIntersection<T>
Формирует список L, содержащий элементы, которые входят одновременно в оба списка L1 и L2.

ПОЛЯ КЛАССА:
- private List<T> L1 - первый список
- private List<T> L2 - второй список
- private List<T> L - результирующий список (пересечение)

КОНСТРУКТОРЫ:
- ListIntersection() - создает пустые списки
- ListIntersection(List<T> L1, List<T> L2) - создает с готовыми списками

ОСНОВНЫЕ МЕТОДЫ:
- addToL1(T element) - добавление элемента в L1
- addToL2(T element) - добавление элемента в L2
- getIntersection() - возвращает пересечение L1 и L2
- calculateIntersection() - вычисляет пересечение

АЛГОРИТМ:
1. Используется HashSet для быстрого поиска
2. Устранение дубликатов в результате
3. Автоматическое обновление при изменении списков

ТЕСТИРОВАНИЕ:
java
ListIntersection<Integer> intersection = new ListIntersection<>();
intersection.addToL1(1); intersection.addToL1(2); intersection.addToL1(3);
intersection.addToL2(3); intersection.addToL2(4); intersection.addToL2(5);
List<Integer> result = intersection.getIntersection(); // [3]


---

 ЗАДАНИЕ 4. MAP - ЛУЧШИЕ УЧЕНИКИ ШКОЛЫ №50

 КЛАСС StudentExamProcessor
Определяет двух лучших учеников школы №50, сдавших экзамен по информатике.

ПОЛЯ КЛАССА:
- List<Student> students - список всех учеников
- List<Student> school50Students - ученики школы №50

КЛАСС Student:
- String lastName - фамилия
- String firstName - имя
- int school - номер школы (1-99)
- int score - балл (1-100)

ОСНОВНЫЕ МЕТОДЫ:
- processStudentsFromFile(String filename) - чтение из файла
- processManualInput(List<Student> students) - обработка ручного ввода
- getIntersection() - возвращает лучших учеников

ЛОГИКА ВЫБОРА:
1. Фильтрация учеников школы №50
2. Проверка, что их не менее 5
3. Сортировка по баллам (убывание)
4. Определение лучших по правилам:
   - Если максимальный балл у >2 учеников → вывод количества
   - Если у ровно 2 учеников → вывод их фамилий и имен
   - Если у 1 ученика → вывод только лучшего

ФОРМАТ ВХОДНЫХ ДАННЫХ:

6
Иванов Сергей 50 87
Петров Иван 50 95
Сидоров Алексей 50 92
Кузнецов Михаил 50 92
Смирнов Дмитрий 50 85
Васильев Андрей 49 98


---

 ЗАДАНИЕ 5. SET - ГЛУХИЕ СОГЛАСНЫЕ В НЕЧЕТНЫХ СЛОВАХ

 КЛАСС FileRead
Находит все глухие согласные буквы, которые входят в каждое нечетное слово текста.

ПОЛЯ КЛАССА:
- private Set<Character> voicelessConsonants - множество глухих согласных

ГЛУХИЕ СОГЛАСНЫЕ:
п, ф, к, т, ш, с, х, ц, ч, щ

ОСНОВНЫЕ МЕТОДЫ:
- analyzeFile(String filename) - анализ файла и возврат результата
- analyzeText(String text) - анализ строкового текста
- printResult(Set<Character> consonants) - вывод результата

АЛГОРИТМ АНАЛИЗА:
1. Разбиение текста на слова
2. Нумерация слов: 1, 2, 3, ...
3. Выбор нечетных слов (1, 3, 5, ...)
4. Нахождение глухих согласных в каждом нечетном слове
5. Поиск пересечения (согласные, которые есть в КАЖДОМ нечетном слове)
6. Сортировка по алфавиту через TreeSet

ТЕСТИРОВАНИЕ:
java
FileRead analyzer = new FileRead();
String text = "пакет такт пакт такт";
Set<Character> result = analyzer.analyzeText(text); // [п, к, т]


---

 ЗАДАНИЕ 6. ОЧЕРЕДЬ - ПРОВЕРКА РАВЕНСТВА УЧАСТКА ОЧЕРЕДИ

 КЛАСС QueueEqualityChecker<T>
Проверяет равенство участка очереди с i-го по j-й элемент (i < j).

ПОЛЯ КЛАССА:
- private Queue<T> queue - основная очередь

ОСНОВНЫЕ МЕТОДЫ:
- add(T element) - добавление элемента
- checkEquality(int i, int j) - проверка равенства элементов на участке
- isAllEqual() - проверка, все ли элементы очереди равны
- findEqualSegments(int length) - поиск всех участков заданной длины с равными элементами

АЛГОРИТМ ПРОВЕРКИ:
1. Преобразование очереди в список для индексации
2. Получение элемента с индексом i как эталона
3. Сравнение всех элементов от i+1 до j с эталоном
4. Если все равны → true, иначе → false

ТЕСТИРОВАНИЕ:
java
Queue<Integer> queue = new ArrayDeque<>(Arrays.asList(1, 1, 1, 2, 2, 2));
QueueEqualityChecker<Integer> checker = new QueueEqualityChecker<>(queue);
boolean result1 = checker.checkEquality(0, 2); // true (1, 1, 1)
boolean result2 = checker.checkEquality(0, 3); // false (1, 1, 1, 2)


---

 ЗАДАНИЕ 7. STREAM API

 7.1. ОБРАБОТКА ТОЧЕК И ПОСТРОЕНИЕ ЛОМАНОЙ

КЛАСС Point:
- Координаты x, y (double)
- toString() в формате "{X;Y}"
- Переопределенные equals() и hashCode()

КЛАСС Polyline:
- Массив точек Point[] points
- toString() в формате "Линия [{X1;Y1},{X2;Y2},...]"

КЛАСС Line:
- Начальная и конечная точки
- toString() в формате "Линия от {X1;Y1} до {X2;Y2}"

STREAM ОБРАБОТКА В PolylineStream:
java
Point[] processedPoints = Arrays.stream(points)
    .filter(Objects::nonNull)        // Убрать null
    .distinct()                     // Уникальные координаты
    .sorted(Comparator.comparingDouble(Point::getX)) // Сортировка по X
    .map(point -> {                 // Абсолютные значения Y
        if (point.getY() < 0) {
            return new Point(point.getX(), Math.abs(point.getY()));
        }
        return point;
    })
    .toArray(Point[]::new);


 7.2. ОБРАБОТКА ФАЙЛА С ЛЮДЬМИ И НОМЕРАМИ

STREAM ОБРАБОТКА В PersonProcessor:
java
Map<Integer, List<String>> result = Files.lines(Paths.get(filename))
    .filter(line -> line != null && !line.trim().isEmpty())
    .map(line -> line.split(":"))
    .filter(parts -> parts.length >= 2 && !parts[1].trim().isEmpty())
    .map(parts -> new String[]{normalizeName(parts[0]), parts[1].trim()})
    .collect(Collectors.groupingBy(
        parts -> Integer.parseInt(parts[1]),
        Collectors.mapping(parts -> parts[0], Collectors.toList())
    ));


НОРМАЛИЗАЦИЯ ИМЕН:
Первая буква заглавная, остальные строчные

---

 СТРУКТУРА ПАКЕТОВ


ru.mamchekova
├── fractions      // дроби с кэшированием
├── cats           // коты и мяуканье
├── list           // пересечение списков
├── student        // ученики школы №50
├── file           // анализ файлов
├── queue          // проверка очереди
├── stream         // Stream API
├── menu           // система меню
└── main           // точка входа


---

 СИСТЕМА МЕНЮ И ТЕСТИРОВАНИЯ

 КЛАСС MenuAndValidator
Полная система тестирования всех реализованных функциональностей.

ВОЗМОЖНОСТИ СИСТЕМЫ:
- Два режима ввода: ручной и автоматический
- Полная валидация входных данных
- Обработка исключений и ошибок
- Наглядное представление результатов

СТРУКТУРА МЕНЮ:
1. Выбор способа ввода (ручной/авто)
2. Выбор задания (1-7)
3. Интерактивный ввод данных или готовые тесты
4. Вывод результатов с подробным объяснением

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- Защита от некорректного ввода
- Подробные сообщения об ошибках
- Дружественный пользовательский интерфейс
- Поддержка всех типов данных

---

 ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ

РЕАЛИЗОВАННЫЕ ПАТТЕРНЫ:
1. Делегирование (Delegation) - в счетчике мяуканий
2. Интерфейсы - для обеспечения гибкости архитектуры
3. Кэширование (Caching) - в классе Fraction
4. Фабричный метод - создание объектов в системе меню

---

 ПРИНЦИПЫ STREAM API

ОСНОВНЫЕ ОПЕРАЦИИ:
- filter() - фильтрация элементов
- map() - преобразование элементов
- distinct() - удаление дубликатов
- sorted() - сортировка элементов
- collect() - терминальные операции с коллекторами

КОЛЛЕКТОРЫ:
- Collectors.groupingBy() - группировка по ключу
- Collectors.mapping() - преобразование при группировке
- Collectors.toList() - сбор в список

---

 ЗАКЛЮЧЕНИЕ

Все задачи варианта 8 успешно реализованы и протестированы:

1. Задание 1 - Дроби с кэшированием и интерфейсом
2. Задание 2 - Подсчет количества мяуканий котов
3. Задание 3 - Пересечение двух списков
4. Задание 4 - Определение лучших учеников школы №50
5. Задание 5 - Глухие согласные в нечетных словах текста
6. Задание 6 - Проверка равенства участка очереди
7. Задание 7.1 - Stream обработка точек и построение ломаной
8. Задание 7.2 - Stream обработка файла с группировкой по номерам

Программа демонстрирует практическое применение шаблонов ООП, коллекций, Stream API и функционального программирования в Java, обеспечивая модульность, гибкость и удобство использования.
